{"version":3,"sources":["../../../src/core/geometry/Geometry.js"],"names":["byteSizeMap","UID","map","Float32Array","Uint32Array","Int32Array","Uint8Array","Uint16Array","Geometry","buffers","attributes","indexBuffer","glVertexArrayObjects","id","instanced","instanceCount","_size","addAttribute","buffer","size","normalised","type","stride","start","instance","Error","data","Array","ids","split","length","i","bufferIndex","indexOf","push","getAttribute","addIndex","index","getIndex","interleave","arrays","sizes","interleavedBuffer","attribute","destroy","getSize","clone","geometry","slice","attrib","normalized","merge","geometries","geometryOut","offsets","j","set","offset","offset2","bufferIndexToCount","indexBufferData"],"mappings":"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","file":"Geometry.js","sourcesContent":["import Attribute from './Attribute';\nimport Buffer from './Buffer';\nimport interleaveTypedArrays from '../utils/interleaveTypedArrays';\nimport getBufferType from '../utils/getBufferType';\n\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nlet UID = 0;\n\n/* eslint-disable object-shorthand */\nconst map = {\n    Float32Array: Float32Array,\n    Uint32Array: Uint32Array,\n    Int32Array: Int32Array,\n    Uint8Array: Uint8Array,\n    Uint16Array: Uint16Array,\n};\n\n/* eslint-disable max-len */\n\n/**\n * The Geometry represents a model. It consists of two components:\n * GeometryStyle - The structure of the model such as the attributes layout\n * GeometryData - the data of the model - this consits of buffers.\n *\n * This can include anything from positions, uvs, normals, colors etc..\n *\n * Geometry can be defined without passing in a style or data if required (thats how I prefer!)\n *\n * ```js\n * let geometry = new PIXI.mesh.Geometry();\n *\n * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);\n * geometry.addAttribute('uvs', [0,0,1,0,1,1,0,1],2)\n * geometry.addIndex([0,1,2,1,3,2])\n *\n * ```\n * @class\n * @memberof PIXI.mesh.Geometry\n */\nexport default class Geometry\n{\n    /**\n     * @param {array} buffers  an array of buffers. optional.\n     * @param {object} attributes of the geometry, optional structure of the attributes layout\n     */\n    constructor(buffers, attributes)\n    {\n        this.buffers = buffers || [];\n\n        this.indexBuffer = null;\n\n        this.attributes = attributes || {};\n\n        /**\n         * A map of renderer IDs to webgl VAOs\n         *\n         * @private\n         * @type {Array<VertexArrayObject>}\n         */\n        this.glVertexArrayObjects = {};\n\n        this.id = UID++;\n\n        this.instanced = false;\n\n        this.instanceCount = 1;\n\n        this._size = null;\n    }\n\n    /**\n    *\n    * Adds an attribute to the geometry\n    *\n    * @param {String} id - the name of the attribute (matching up to a shader)\n    * @param {PIXI.mesh.Buffer} [buffer] the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.\n    * @param {Number} [size=0] the size of the attribute. If you hava 2 floats per vertex (eg position x and y) this would be 2\n    * @param {Boolean} [normalised=false] should the data be normalised.\n    * @param {Number} [type=PIXI.TYPES.FLOAT] what type of numbe is the attribute. Check {PIXI.TYPES} to see the ones available\n    * @param {Number} [stride=0] How far apart (in floats) the start of each value is. (used for interleaving data)\n    * @param {Number} [start=0] How far into the array to start reading values (used for interleaving data)\n    *\n    * @return {PIXI.mesh.Geometry} returns self, useful for chaining.\n    */\n    addAttribute(id, buffer, size, normalised = false, type, stride, start, instance = false)\n    {\n        if (!buffer)\n        {\n            throw new Error('You must pass a buffer when creating an attribute');\n        }\n\n        // check if this is a buffer!\n        if (!buffer.data)\n        {\n            // its an array!\n            if (buffer instanceof Array)\n            {\n                buffer = new Float32Array(buffer);\n            }\n\n            buffer = new Buffer(buffer);\n        }\n\n        const ids = id.split('|');\n\n        if (ids.length > 1)\n        {\n            for (let i = 0; i < ids.length; i++)\n            {\n                this.addAttribute(ids[i], buffer, size, normalised, type);\n            }\n\n            return this;\n        }\n\n        let bufferIndex = this.buffers.indexOf(buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(buffer);\n            bufferIndex = this.buffers.length - 1;\n        }\n\n        this.attributes[id] = new Attribute(bufferIndex, size, normalised, type, stride, start, instance);\n\n        // assuming that if there is instanced data then this will be drawn with instancing!\n        this.instanced = this.instanced || instance;\n\n        return this;\n    }\n\n    /**\n     * returns the requested attribute\n     *\n     * @param {String} id  the name of the attribute required\n     * @return {PIXI.mesh.Attribute} the attribute requested.\n     */\n    getAttribute(id)\n    {\n        return this.buffers[this.attributes[id].buffer];\n    }\n\n    /**\n    *\n    * Adds an index buffer to the geometry\n    * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.\n    *\n    * @param {PIXI.mesh.Buffer} [buffer] the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.\n    * @return {PIXI.mesh.Geometry} returns self, useful for chaining.\n    */\n    addIndex(buffer)\n    {\n        if (!buffer.data)\n        {\n            // its an array!\n            if (buffer instanceof Array)\n            {\n                buffer = new Uint16Array(buffer);\n            }\n\n            buffer = new Buffer(buffer);\n        }\n\n        buffer.index = true;\n        this.indexBuffer = buffer;\n\n        if (this.buffers.indexOf(buffer) === -1)\n        {\n            this.buffers.push(buffer);\n        }\n\n        return this;\n    }\n\n    /**\n     * returns the index buffer\n     *\n     * @return {PIXI.mesh.Buffer} the index buffer.\n     */\n    getIndex()\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * this function modifies the structure so that all current attributes become interleaved into a single buffer\n     * This can be useful if your model remains static as it offers a little performance boost\n     *\n     * @return {PIXI.mesh.Geometry} returns self, useful for chaining.\n     */\n    interleave()\n    {\n        // a simple check to see if buffers are already interleaved..\n        if (this.buffers.length === 1 || (this.buffers.length === 2 && this.indexBuffer)) return this;\n\n        // assume already that no buffers are interleaved\n        const arrays = [];\n        const sizes = [];\n        const interleavedBuffer = new Buffer();\n        let i;\n\n        for (i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n\n            const buffer = this.buffers[attribute.buffer];\n\n            arrays.push(buffer.data);\n\n            sizes.push((attribute.size * byteSizeMap[attribute.type]) / 4);\n\n            attribute.buffer = 0;\n        }\n\n        interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);\n\n        for (i = 0; i < this.buffers.length; i++)\n        {\n            if (this.buffers[i] !== this.indexBuffer)\n            {\n                this.buffers[i].destroy();\n            }\n        }\n\n        this.buffers = [interleavedBuffer];\n\n        if (this.indexBuffer)\n        {\n            this.buffers.push(this.indexBuffer);\n        }\n\n        return this;\n    }\n\n    getSize()\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = this.buffers[attribute.buffer];\n\n            return buffer.data.length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Destroys the geometry.\n     */\n    destroy()\n    {\n        for (let i = 0; i < this.glVertexArrayObjects.length; i++)\n        {\n            this.glVertexArrayObjects[i].destroy();\n        }\n\n        this.glVertexArrayObjects = null;\n\n        for (let i = 0; i < this.buffers.length; i++)\n        {\n            this.buffers[i].destroy();\n        }\n\n        this.buffers = null;\n        this.indexBuffer.destroy();\n\n        this.attributes = null;\n    }\n\n    /**\n     * returns a clone of the geometry\n     *\n     * @returns {PIXI.mesh.Geometry} a new clone of this geometry\n     */\n    clone()\n    {\n        const geometry = new Geometry();\n\n        for (let i = 0; i < this.buffers.length; i++)\n        {\n            geometry.buffers[i] = new Buffer(this.buffers[i].data.slice());\n        }\n\n        for (const i in this.attributes)\n        {\n            const attrib = this.attributes[i];\n\n            geometry.attributes[i] = new Attribute(\n                attrib.buffer,\n                attrib.size,\n                attrib.normalized,\n                attrib.type,\n                attrib.stride,\n                attrib.start,\n                attrib.instance\n            );\n        }\n\n        if (this.indexBuffer)\n        {\n            geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];\n            geometry.indexBuffer.index = true;\n        }\n\n        return geometry;\n    }\n\n    /**\n     * merges an array of geometries into a new single one\n     * geometry attribute styles must match for this operation to work\n     *\n     * @param {array|PIXI.mesh.Geometry} geometries array of geometries to merge\n     * @returns {PIXI.mesh.Geometry} shiney new geometry\n     */\n    static merge(geometries)\n    {\n        // todo add a geometry check!\n        // also a size check.. cant be too big!]\n\n        const geometryOut = new Geometry();\n\n        const arrays = [];\n        const sizes = [];\n        const offsets = [];\n\n        let geometry;\n\n        // pass one.. get sizes..\n        for (let i = 0; i < geometries.length; i++)\n        {\n            geometry = geometries[i];\n\n            for (let j = 0; j < geometry.buffers.length; j++)\n            {\n                sizes[j] = sizes[j] || 0;\n                sizes[j] += geometry.buffers[j].data.length;\n                offsets[j] = 0;\n            }\n        }\n\n        // build the correct size arrays..\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            // TODO types!\n            arrays[i] = new map[getBufferType(geometry.buffers[i].data)](sizes[i]);\n            geometryOut.buffers[i] = new Buffer(arrays[i]);\n        }\n\n        // pass to set data..\n        for (let i = 0; i < geometries.length; i++)\n        {\n            geometry = geometries[i];\n\n            for (let j = 0; j < geometry.buffers.length; j++)\n            {\n                arrays[j].set(geometry.buffers[j].data, offsets[j]);\n                offsets[j] += geometry.buffers[j].data.length;\n            }\n        }\n\n        geometryOut.attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];\n            geometryOut.indexBuffer.index = true;\n\n            let offset = 0;\n            let stride = 0;\n            let offset2 = 0;\n            let bufferIndexToCount = 0;\n\n            // get a buffer\n            for (let i = 0; i < geometry.buffers.length; i++)\n            {\n                if (geometry.buffers[i] !== geometry.indexBuffer)\n                {\n                    bufferIndexToCount = i;\n                    break;\n                }\n            }\n\n            // figure out the stride of one buffer..\n            for (const i in geometry.attributes)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.buffer | 0) === bufferIndexToCount)\n                {\n                    stride += ((attribute.size * byteSizeMap[attribute.type]) / 4);\n                }\n            }\n\n            // time to off set all indexes..\n            for (let i = 0; i < geometries.length; i++)\n            {\n                const indexBufferData = geometries[i].indexBuffer.data;\n\n                for (let j = 0; j < indexBufferData.length; j++)\n                {\n                    geometryOut.indexBuffer.data[j + offset2] += offset;\n                }\n\n                offset += geometry.buffers[bufferIndexToCount].data.length / (stride);\n                offset2 += indexBufferData.length;\n            }\n        }\n\n        return geometryOut;\n    }\n}\n"]}