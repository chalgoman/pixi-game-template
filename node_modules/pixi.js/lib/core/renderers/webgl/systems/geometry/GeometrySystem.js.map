{"version":3,"sources":["../../../../../../src/core/renderers/webgl/systems/geometry/GeometrySystem.js"],"names":["byteSizeMap","GLBufferData","buffer","updateID","byteLength","GeometrySystem","renderer","_activeGeometry","_activeVao","hasVao","hasInstance","contextChange","gl","CONTEXT_UID","createVertexArray","nativeVaoExtension","context","extensions","vertexArrayObject","legacy","createVertexArrayOES","bindVertexArray","vao","bindVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","vertexAttribDivisor","instanceExt","getExtension","a","b","vertexAttribDivisorANGLE","drawElementsInstanced","c","d","e","drawElementsInstancedANGLE","drawArraysInstanced","drawArraysInstancedANGLE","bind","geometry","shader","vaos","glVertexArrayObjects","program","id","initGeometryVao","activateVao","updateBuffers","i","buffers","length","glBuffer","_glBuffers","_updateID","type","index","ELEMENT_ARRAY_BUFFER","ARRAY_BUFFER","drawType","static","STATIC_DRAW","DYNAMIC_DRAW","bindBuffer","data","bufferSubData","bufferData","checkCompatability","geometryAttributes","attributes","shaderAttributes","attributeData","j","Error","tempStride","tempStart","size","attribute","attribSize","stride","undefined","start","createBuffer","indexBuffer","lastBuffer","location","enableVertexAttribArray","vertexAttribPointer","FLOAT","normalized","instance","draw","instanceCount","instanced","UNSIGNED_SHORT","drawElements","getSize","drawArrays","unbind"],"mappings":"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","file":"GeometrySystem.js","sourcesContent":["import WebGLSystem from '../WebGLSystem';\n\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\n\nclass GLBufferData\n{\n    constructor(buffer)\n    {\n        this.buffer = buffer;\n        this.updateID = -1;\n        this.byteLength = -1;\n    }\n}\n\n/**\n * @class\n * @extends PIXI.WebGLSystem\n * @memberof PIXI\n */\nexport default class GeometrySystem extends WebGLSystem\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    contextChange()\n    {\n        const gl = this.gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // webgl2\n        if (!gl.createVertexArray)\n        {\n            // webgl 1!\n            let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n\n            if (this.renderer.legacy)\n            {\n                nativeVaoExtension = null;\n            }\n\n            if (nativeVaoExtension)\n            {\n                gl.createVertexArray = () =>\n                    nativeVaoExtension.createVertexArrayOES();\n\n                gl.bindVertexArray = (vao) =>\n                    nativeVaoExtension.bindVertexArrayOES(vao);\n\n                gl.deleteVertexArray = (vao) =>\n                    nativeVaoExtension.deleteVertexArrayOES(vao);\n            }\n            else\n            {\n                this.hasVao = false;\n                gl.createVertexArray = () =>\n                {\n                    // empty\n                };\n\n                gl.bindVertexArray = () =>\n                {\n                    // empty\n                };\n\n                gl.deleteVertexArray = () =>\n                {\n                    // empty\n                };\n            }\n        }\n\n        if (!gl.vertexAttribDivisor)\n        {\n            const instanceExt = gl.getExtension('ANGLE_instanced_arrays');\n\n            if (instanceExt)\n            {\n                gl.vertexAttribDivisor = (a, b) =>\n                    instanceExt.vertexAttribDivisorANGLE(a, b);\n\n                gl.drawElementsInstanced = (a, b, c, d, e) =>\n                    instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n\n                gl.drawArraysInstanced = (a, b, c, d) =>\n                    instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n            }\n            else\n            {\n                this.hasInstance = false;\n            }\n        }\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @private\n     * @param {PIXI.mesh.Geometry} geometry instance of geometry to bind\n     */\n    bind(geometry, shader)\n    {\n        shader = shader || this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        // not sure the best way to address this..\n        // currently different shaders require different VAOs for the same geometry\n        // Still mulling over the best way to solve this one..\n        // will likely need to modify the shader attribute locations at run time!\n        let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n\n        if (!vaos)\n        {\n            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n        }\n\n        const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program);\n\n        this._activeGeometry = geometry;\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            if (this.hasVao)\n            {\n                gl.bindVertexArray(vao);\n            }\n            else\n            {\n                this.activateVao(geometry, shader.program);\n            }\n        }\n\n        // TODO - optimise later!\n        // don't need to loop through if nothing changed!\n        // maybe look to add an 'autoupdate' to geometry?\n        this.updateBuffers();\n    }\n\n    updateBuffers()\n    {\n        const geometry = this._activeGeometry;\n        const gl = this.gl;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n\n            if (buffer._updateID !== glBuffer.updateID)\n            {\n                glBuffer.updateID = buffer._updateID;\n\n                // TODO can cache this on buffer! maybe added a getter / setter?\n                const type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n                gl.bindBuffer(type, glBuffer.buffer);\n\n                if (glBuffer.byteLength >= buffer.data.byteLength)\n                {\n                    // offset is always zero for now!\n                    gl.bufferSubData(type, 0, buffer.data);\n                }\n                else\n                {\n                    gl.bufferData(type, buffer.data, drawType);\n                }\n            }\n        }\n    }\n\n    checkCompatability(geometry, program)\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Creates a Vao with the same structure as the geometry and stores it on the geometry.\n     * @private\n     * @param {PIXI.mesh.Geometry} geometry instance of geometry to to generate Vao for\n     */\n    initGeometryVao(geometry, program)\n    {\n        this.checkCompatability(geometry, program);\n\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n\n        const tempStride = {};\n        const tempStart = {};\n\n        for (const j in buffers)\n        {\n            tempStride[j] = 0;\n            tempStart[j] = 0;\n        }\n\n        for (const j in attributes)\n        {\n            if (!attributes[j].size && program.attributeData[j])\n            {\n                attributes[j].size = program.attributeData[j].size;\n            }\n\n            tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n        }\n\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const attribSize = attribute.size;\n\n            if (attribute.stride === undefined)\n            {\n                if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type])\n                {\n                    attribute.stride = 0;\n                }\n                else\n                {\n                    attribute.stride = tempStride[attribute.buffer];\n                }\n            }\n\n            if (attribute.start === undefined)\n            {\n                attribute.start = tempStart[attribute.buffer];\n\n                tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n            }\n        }\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            if (!buffer._glBuffers[CONTEXT_UID])\n            {\n                buffer._glBuffers[CONTEXT_UID] = new GLBufferData(gl.createBuffer());\n            }\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n        const vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        this.activateVao(geometry, program);\n\n        gl.bindVertexArray(null);\n\n        // add it to the cache!\n        geometry.glVertexArrayObjects[this.CONTEXT_UID][program.id] = vao;\n\n        return vao;\n    }\n\n    activateVao(geometry, program)\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = buffers[attribute.buffer];\n            const glBuffer = buffer._glBuffers[CONTEXT_UID];\n\n            if (program.attributeData[j])\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = program.attributeData[j].location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                gl.vertexAttribPointer(location,\n                                       attribute.size,\n                                       attribute.type || gl.FLOAT,\n                                       attribute.normalized,\n                                       attribute.stride,\n                                       attribute.start);\n\n                if (attribute.instance)\n                {\n                     // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, 1);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    draw(type, size, start, instanceCount)\n    {\n        const gl = this.gl;\n        const geometry = this._activeGeometry;\n\n        // TODO.. this should not change so maybe cache the function?\n\n        if (geometry.indexBuffer)\n        {\n            if (geometry.instanced)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2, instanceCount || 1);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                gl.drawElements(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2);\n            }\n        }\n        else\n        if (geometry.instanced)\n            {\n                // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n        }\n            else\n            {\n            gl.drawArrays(type, start, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    unbind()\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n}\n"]}