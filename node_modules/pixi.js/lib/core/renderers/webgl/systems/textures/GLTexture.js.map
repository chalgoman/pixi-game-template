{"version":3,"sources":["../../../../../../src/core/renderers/webgl/systems/textures/GLTexture.js"],"names":["FLOATING_POINT_AVAILABLE","Texture","gl","width","height","format","type","texture","createTexture","mipmap","premultiplyAlpha","RGBA","UNSIGNED_BYTE","upload","source","bind","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","newWidth","videoWidth","newHeight","videoHeight","texImage2D","TEXTURE_2D","texSubImage2D","uploadData","data","Float32Array","ext","getExtension","Error","FLOAT","location","undefined","activeTexture","TEXTURE0","bindTexture","unbind","minFilter","linear","texParameteri","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR","NEAREST","magFilter","TEXTURE_MAG_FILTER","enableMipmap","generateMipmap","enableLinearScaling","enableNearestScaling","enableWrapClamp","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","enableWrapRepeat","REPEAT","enableWrapMirrorRepeat","MIRRORED_REPEAT","destroy","deleteTexture","fromSource","fromData"],"mappings":"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","file":"GLTexture.js","sourcesContent":["let FLOATING_POINT_AVAILABLE = false;\n\n/**\n * Helper class to create a WebGL Texture\n *\n * @class\n * @memberof PIXI.glCore\n * @param gl {WebGLRenderingContext} The current WebGL context\n * @param width {number} the width of the texture\n * @param height {number} the height of the texture\n * @param format {number} the pixel format of the texture. defaults to gl.RGBA\n * @param type {number} the gl type of the texture. defaults to gl.UNSIGNED_BYTE\n */\nexport default class Texture\n{\n    constructor(gl, width, height, format, type)\n    {\n        /**\n         * The current WebGL rendering context\n         *\n         * @member {WebGLRenderingContext}\n         */\n        this.gl = gl;\n\n        /**\n         * The WebGL texture\n         *\n         * @member {WebGLTexture}\n         */\n        this.texture = gl.createTexture();\n\n        /**\n         * If mipmapping was used for this texture, enable and disable with enableMipmap()\n         *\n         * @member {Boolean}\n         */\n        // some settings..\n        this.mipmap = false;\n\n        /**\n         * Set to true to enable pre-multiplied alpha\n         *\n         * @member {Boolean}\n         */\n        this.premultiplyAlpha = false;\n\n        /**\n         * The width of texture\n         *\n         * @member {Number}\n         */\n        this.width = width || -1;\n        /**\n         * The height of texture\n         *\n         * @member {Number}\n         */\n        this.height = height || -1;\n\n        /**\n         * The pixel format of the texture. defaults to gl.RGBA\n         *\n         * @member {Number}\n         */\n        this.format = format || gl.RGBA;\n\n        /**\n         * The gl type of the texture. defaults to gl.UNSIGNED_BYTE\n         *\n         * @member {Number}\n         */\n        this.type = type || gl.UNSIGNED_BYTE;\n    }\n\n    /**\n     * Uploads this texture to the GPU\n     * @param source {HTMLImageElement|ImageData|HTMLVideoElement} the source image of the texture\n     */\n    upload(source)\n    {\n        this.bind();\n\n        const gl = this.gl;\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n\n        const newWidth = source.videoWidth || source.width;\n        const newHeight = source.videoHeight || source.height;\n\n        if (newHeight !== this.height || newWidth !== this.width)\n        {\n            gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source);\n        }\n        else\n        {\n            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source);\n        }\n\n        // if the source is a video, we need to use the videoWidth / videoHeight\n        // properties as width / height will be incorrect.\n        this.width = newWidth;\n        this.height = newHeight;\n    }\n\n    /**\n     * Use a data source and uploads this texture to the GPU\n     * @param data {TypedArray} the data to upload to the texture\n     * @param width {number} the new width of the texture\n     * @param height {number} the new height of the texture\n     */\n    uploadData(data, width, height)\n    {\n        this.bind();\n\n        const gl = this.gl;\n\n        if (data instanceof Float32Array)\n        {\n            if (!FLOATING_POINT_AVAILABLE)\n            {\n                const ext = gl.getExtension('OES_texture_float');\n\n                if (ext)\n                {\n                    FLOATING_POINT_AVAILABLE = true;\n                }\n                else\n                {\n                    throw new Error('floating point textures not available');\n                }\n            }\n\n            this.type = gl.FLOAT;\n        }\n        else\n        {\n            // TODO support for other types\n            this.type = this.type || gl.UNSIGNED_BYTE;\n        }\n\n        // what type of data?\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n\n        if (width !== this.width || height !== this.height)\n        {\n            gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, data || null);\n        }\n        else\n        {\n            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null);\n        }\n\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     * Binds the texture\n     * @param  location\n     */\n    bind(location)\n    {\n        const gl = this.gl;\n\n        if (location !== undefined)\n        {\n            gl.activeTexture(gl.TEXTURE0 + location);\n        }\n\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\n    }\n\n    /**\n     * Unbinds the texture\n     */\n    unbind()\n    {\n        const gl = this.gl;\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    /**\n     * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation\n     */\n    minFilter(linear)\n    {\n        const gl = this.gl;\n\n        this.bind();\n\n        if (this.mipmap)\n        {\n            /* eslint-disable max-len */\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n            /* eslint-disable max-len */\n        }\n        else\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);\n        }\n    }\n\n    /**\n     * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation\n     */\n    magFilter(linear)\n    {\n        const gl = this.gl;\n\n        this.bind();\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);\n    }\n\n    /**\n     * Enables mipmapping\n     */\n    enableMipmap()\n    {\n        const gl = this.gl;\n\n        this.bind();\n\n        this.mipmap = true;\n\n        gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    /**\n     * Enables linear filtering\n     */\n    enableLinearScaling()\n    {\n        this.minFilter(true);\n        this.magFilter(true);\n    }\n\n    /**\n     * Enables nearest neighbour interpolation\n     */\n    enableNearestScaling()\n    {\n        this.minFilter(false);\n        this.magFilter(false);\n    }\n\n    /**\n     * Enables clamping on the texture so WebGL will not repeat it\n     */\n    enableWrapClamp()\n    {\n        const gl = this.gl;\n\n        this.bind();\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n\n    enableWrapRepeat()\n    {\n        const gl = this.gl;\n\n        this.bind();\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    }\n\n    enableWrapMirrorRepeat()\n    {\n        const gl = this.gl;\n\n        this.bind();\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n    }\n\n    /**\n     * Destroys this texture\n     */\n    destroy()\n    {\n        const gl = this.gl;\n        // TODO\n\n        gl.deleteTexture(this.texture);\n    }\n\n    /**\n     * @static\n     * @param gl {WebGLRenderingContext} The current WebGL context\n     * @param source {HTMLImageElement|ImageData} the source image of the texture\n     * @param premultiplyAlpha {Boolean} If we want to use pre-multiplied alpha\n     */\n    static fromSource(gl, source, premultiplyAlpha)\n    {\n        const texture = new Texture(gl);\n\n        texture.premultiplyAlpha = premultiplyAlpha || false;\n        texture.upload(source);\n\n        return texture;\n    }\n\n    /**\n     * @static\n     * @param gl {WebGLRenderingContext} The current WebGL context\n     * @param data {TypedArray} the data to upload to the texture\n     * @param width {number} the new width of the texture\n     * @param height {number} the new height of the texture\n     */\n    static fromData(gl, data, width, height)\n    {\n        // console.log(data, width, height);\n        const texture = new Texture(gl);\n\n        texture.uploadData(data, width, height);\n\n        return texture;\n    }\n}\n"]}