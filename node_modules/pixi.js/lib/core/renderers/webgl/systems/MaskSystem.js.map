{"version":3,"sources":["../../../../../src/core/renderers/webgl/systems/MaskSystem.js"],"names":["MaskSystem","renderer","scissor","scissorData","scissorRenderTarget","enableScissor","alphaMaskPool","alphaMaskIndex","push","target","maskData","texture","pushSpriteMask","_activeRenderTarget","root","stencil","stencilMaskStack","length","isFastRect","matrix","worldTransform","rot","Math","atan2","b","a","round","PI","pushStencilMask","pushScissorMask","pop","popSpriteMask","popScissorMask","popStencilMask","alphaMaskFilter","resolution","maskSprite","filterArea","getBounds","filterSystem","pushFilter","popFilter","batch","flush","pushStencil","popStencil","renderable","renderTarget","bounds","fit","size","gl","enable","SCISSOR_TEST","x","height","y","width","disable"],"mappings":"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","file":"MaskSystem.js","sourcesContent":["import WebGLSystem from './WebGLSystem';\nimport AlphaMaskFilter from '../filters/spriteMask/SpriteMaskFilter';\n\n/**\n * @class\n * @extends PIXI.WebGLSystem\n * @memberof PIXI\n */\nexport default class MaskSystem extends WebGLSystem\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        // TODO - we don't need both!\n        this.scissor = false;\n        this.scissorData = null;\n        this.scissorRenderTarget = null;\n\n        this.enableScissor = false;\n\n        this.alphaMaskPool = [];\n        this.alphaMaskIndex = 0;\n    }\n\n    /**\n     * Applies the Mask and adds it to the current filter stack.\n     *\n     * @param {PIXI.DisplayObject} target - Display Object to push the mask to\n     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.\n     */\n    push(target, maskData)\n    {\n        // TODO the root check means scissor rect will not\n        // be used on render textures more info here:\n        // https://github.com/pixijs/pixi.js/pull/3545\n\n        if (maskData.texture)\n        {\n            this.pushSpriteMask(target, maskData);\n        }\n        else if (this.enableScissor\n            && !this.scissor\n            && this.renderer._activeRenderTarget.root\n            && !this.renderer.stencil.stencilMaskStack.length\n            && maskData.isFastRect())\n        {\n            const matrix = maskData.worldTransform;\n\n            let rot = Math.atan2(matrix.b, matrix.a);\n\n            // use the nearest degree!\n            rot = Math.round(rot * (180 / Math.PI));\n\n            if (rot % 90)\n            {\n                this.pushStencilMask(maskData);\n            }\n            else\n            {\n                this.pushScissorMask(target, maskData);\n            }\n        }\n        else\n        {\n            this.pushStencilMask(maskData);\n        }\n    }\n\n    /**\n     * Removes the last mask from the mask stack and doesn't return it.\n     *\n     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from\n     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.\n     */\n    pop(target, maskData)\n    {\n        if (maskData.texture)\n        {\n            this.popSpriteMask(target, maskData);\n        }\n        else if (this.enableScissor && !this.renderer.stencil.stencilMaskStack.length)\n        {\n            this.popScissorMask(target, maskData);\n        }\n        else\n        {\n            this.popStencilMask(target, maskData);\n        }\n    }\n\n    /**\n     * Applies the Mask and adds it to the current filter stack.\n     *\n     * @param {PIXI.RenderTarget} target - Display Object to push the sprite mask to\n     * @param {PIXI.Sprite} maskData - Sprite to be used as the mask\n     */\n    pushSpriteMask(target, maskData)\n    {\n        let alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n\n        if (!alphaMaskFilter)\n        {\n            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new AlphaMaskFilter(maskData)];\n        }\n\n        alphaMaskFilter[0].resolution = this.renderer.resolution;\n        alphaMaskFilter[0].maskSprite = maskData;\n\n        // TODO - may cause issues!\n        target.filterArea = maskData.getBounds(true);\n\n        this.renderer.filterSystem.pushFilter(target, alphaMaskFilter);\n\n        this.alphaMaskIndex++;\n    }\n\n    /**\n     * Removes the last filter from the filter stack and doesn't return it.\n     *\n     */\n    popSpriteMask()\n    {\n        this.renderer.filterSystem.popFilter();\n        this.alphaMaskIndex--;\n    }\n\n    /**\n     * Applies the Mask and adds it to the current filter stack.\n     *\n     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.\n     */\n    pushStencilMask(maskData)\n    {\n        this.renderer.batch.flush();\n        this.renderer.stencil.pushStencil(maskData);\n    }\n\n    /**\n     * Removes the last filter from the filter stack and doesn't return it.\n     *\n     */\n    popStencilMask()\n    {\n       // this.renderer.currentRenderer.stop();\n        this.renderer.stencil.popStencil();\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject} target - Display Object to push the mask to\n     * @param {PIXI.Graphics} maskData - The masking data.\n     */\n    pushScissorMask(target, maskData)\n    {\n        maskData.renderable = true;\n\n        const renderTarget = this.renderer._activeRenderTarget;\n\n        const bounds = maskData.getBounds();\n\n        bounds.fit(renderTarget.size);\n        maskData.renderable = false;\n\n        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n\n        const resolution = this.renderer.resolution;\n\n        this.renderer.gl.scissor(\n            bounds.x * resolution,\n            (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution,\n            bounds.width * resolution,\n            bounds.height * resolution\n        );\n\n        this.scissorRenderTarget = renderTarget;\n        this.scissorData = maskData;\n        this.scissor = true;\n    }\n\n    /**\n     *\n     *\n     */\n    popScissorMask()\n    {\n        this.scissorRenderTarget = null;\n        this.scissorData = null;\n        this.scissor = false;\n\n        // must be scissor!\n        const gl = this.renderer.gl;\n\n        gl.disable(gl.SCISSOR_TEST);\n    }\n}\n"]}