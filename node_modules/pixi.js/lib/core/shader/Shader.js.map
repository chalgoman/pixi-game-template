{"version":3,"sources":["../../../src/core/shader/Shader.js"],"names":["Shader","program","uniforms","uniformGroup","i","uniformData","Array","Float32Array","checkUniformExists","name","group","uniform","destroy","from","vertexSrc","fragmentSrc"],"mappings":";;;;;;AAAA;;;;AACA;;;;;;;;AAEA;AACA;;;;;IAKMA,M;AAEF;;;;AAIA,oBAAYC,OAAZ,EAAqBC,QAArB,EACA;AAAA;;AACI,aAAKD,OAAL,GAAeA,OAAf;;AAEA;AACA;AACA,YAAIC,QAAJ,EACA;AACI,gBAAIA,0CAAJ,EACA;AACI,qBAAKC,YAAL,GAAoBD,QAApB;AACH,aAHD,MAKA;AACI,qBAAKC,YAAL,GAAoB,2BAAiBD,QAAjB,CAApB;AACH;AACJ,SAVD,MAYA;AACI,iBAAKC,YAAL,GAAoB,2BAAiB,EAAjB,CAApB;AACH;;AAED;AACA;AACA;AACA,aAAK,IAAMC,CAAX,IAAgBH,QAAQI,WAAxB,EACA;AACI,gBAAI,KAAKF,YAAL,CAAkBD,QAAlB,CAA2BE,CAA3B,aAAyCE,KAA7C,EACA;AACI,qBAAKH,YAAL,CAAkBD,QAAlB,CAA2BE,CAA3B,IAAgC,IAAIG,YAAJ,CAAiB,KAAKJ,YAAL,CAAkBD,QAAlB,CAA2BE,CAA3B,CAAjB,CAAhC;AACH;AACJ;AACJ;;AAED;;;qBACAI,kB,+BAAmBC,I,EAAMC,K,EACzB;AACI,YAAIA,MAAMR,QAAN,CAAeO,IAAf,CAAJ,EACA;AACI,mBAAO,IAAP;AACH;;AAED,aAAK,IAAML,CAAX,IAAgBM,MAAMR,QAAtB,EACA;AACI,gBAAMS,UAAUD,MAAMR,QAAN,CAAeE,CAAf,CAAhB;;AAEA,gBAAIO,QAAQD,KAAZ,EACA;AACI,oBAAI,KAAKF,kBAAL,CAAwBC,IAAxB,EAA8BE,OAA9B,CAAJ,EACA;AACI,2BAAO,IAAP;AACH;AACJ;AACJ;;AAED,eAAO,KAAP;AACH,K;;qBAEDC,O,sBACA;AACI;AACA;AACA,aAAKT,YAAL,GAAoB,IAApB;AACH,K;;AAOD;;;;;;;;;WASOU,I,iBAAKC,S,EAAWC,W,EAAab,Q,EACpC;AACI,YAAMD,UAAU,kBAAQY,IAAR,CAAaC,SAAb,EAAwBC,WAAxB,CAAhB;;AAEA,eAAO,IAAIf,MAAJ,CAAWC,OAAX,EAAoBC,QAApB,CAAP;AACH,K;;;;4BAlBD;AACI,mBAAO,KAAKC,YAAL,CAAkBD,QAAzB;AACH;;;;;;kBAmBUF,M","file":"Shader.js","sourcesContent":["import Program from './Program';\nimport UniformGroup from './UniformGroup';\n\n// let math = require('../../../math');\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n */\nclass Shader\n{\n    /**\n     * @param {PIXI.Program} [program] - The program the shader will use.\n     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.\n     */\n    constructor(program, uniforms)\n    {\n        this.program = program;\n\n        // lets see whats been passed in\n        // uniforms should be converted to a uniform group\n        if (uniforms)\n        {\n            if (uniforms instanceof UniformGroup)\n            {\n                this.uniformGroup = uniforms;\n            }\n            else\n            {\n                this.uniformGroup = new UniformGroup(uniforms);\n            }\n        }\n        else\n        {\n            this.uniformGroup = new UniformGroup({});\n        }\n\n        // time to build some getters and setters!\n        // I guess down the line this could sort of generate an instruction list rather than use dirty ids?\n        // does the trick for now though!\n        for (const i in program.uniformData)\n        {\n            if (this.uniformGroup.uniforms[i] instanceof Array)\n            {\n                this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);\n            }\n        }\n    }\n\n    // TODO move to shader system..\n    checkUniformExists(name, group)\n    {\n        if (group.uniforms[name])\n        {\n            return true;\n        }\n\n        for (const i in group.uniforms)\n        {\n            const uniform = group.uniforms[i];\n\n            if (uniform.group)\n            {\n                if (this.checkUniformExists(name, uniform))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    destroy()\n    {\n        // usage count on programs?\n        // remove if not used!\n        this.uniformGroup = null;\n    }\n\n    get uniforms()\n    {\n        return this.uniformGroup.uniforms;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader\n     *\n     * @param {string} [vertexSrc] - The source of the vertex shader.\n     * @param {string} [fragmentSrc] - The source of the fragment shader.\n     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.\n     *\n     * @returns {PIXI.Shader} an shiney new pixi shader.\n     */\n    static from(vertexSrc, fragmentSrc, uniforms)\n    {\n        const program = Program.from(vertexSrc, fragmentSrc);\n\n        return new Shader(program, uniforms);\n    }\n}\n\nexport default Shader;\n"]}