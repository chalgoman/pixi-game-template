{"version":3,"sources":["../../../src/core/shader/Program.js"],"names":["shaderUtils","UID","Program","vertexSrc","fragmentSrc","defaultVertexSrc","defaultFragmentSrc","extractData","glShaders","syncUniforms","id","gl","attributeData","uniformData","setPrecision","program","compileProgram","getAttributeData","getUniformData","attributes","attributesArray","totalAttributes","getProgramParameter","ACTIVE_ATTRIBUTES","i","attribData","getActiveAttrib","type","mapType","data","name","size","mapSize","location","push","sort","a","b","length","uniforms","totalUniforms","ACTIVE_UNIFORMS","getActiveUniform","replace","isArray","match","value","defaultValue","from","key","join"],"mappings":"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","file":"Program.js","sourcesContent":["import extractUniformsFromSrc from './extractUniformsFromSrc';\nimport * as shaderUtils from '../renderers/webgl/systems/shader/shader';\nimport { ProgramCache } from '../utils';\nimport getTestContext from '../utils/getTestContext';\n\nlet UID = 0;\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n */\nclass Program\n{\n    /**\n     * @param {string} [vertexSrc] - The source of the vertex shader.\n     * @param {string} [fragmentSrc] - The source of the fragment shader.\n     */\n    constructor(vertexSrc, fragmentSrc)\n    {\n        /**\n         * The vertex shader.\n         *\n         * @member {string}\n         */\n        this.vertexSrc = vertexSrc || Program.defaultVertexSrc;\n\n        /**\n         * The fragment shader.\n         *\n         * @member {string}\n         */\n        this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;\n\n        // currently this does not extract structs only default types\n        this.extractData(this.vertexSrc, this.fragmentSrc);\n\n        // this is where we store shader references..\n        this.glShaders = {};\n\n        this.syncUniforms = null;\n\n        this.id = UID++;\n    }\n\n    /**\n     * Extracts the data for a buy creating a small test program\n     * or reading the src directly.\n     * @private\n     *\n     * @param {string} [vertexSrc] - The source of the vertex shader.\n     * @param {string} [fragmentSrc] - The source of the fragment shader.\n     */\n    extractData(vertexSrc, fragmentSrc)\n    {\n        const gl = getTestContext();\n\n        if (!gl)\n        {\n            // uh oh! no webGL.. lets read uniforms from the strings..\n            this.attributeData = {};\n            this.uniformData = extractUniformsFromSrc(vertexSrc, fragmentSrc);\n        }\n        else\n        {\n            vertexSrc = shaderUtils.setPrecision(vertexSrc, 'mediump');\n            fragmentSrc = shaderUtils.setPrecision(fragmentSrc, 'mediump');\n\n            const program = shaderUtils.compileProgram(gl, vertexSrc, fragmentSrc);\n\n            this.attributeData = this.getAttributeData(program, gl);\n            this.uniformData = this.getUniformData(program, gl);\n            // gl.deleteProgram(program);\n        }\n    }\n\n    /**\n     * returns the attribute data from the program\n     * @private\n     *\n     * @param {webGL-program} [program] - the webgl program\n     * @param {contex} [gl] - the webGL context\n     *\n     * @returns {object} the attribute data for this program\n     */\n    getAttributeData(program, gl)\n    {\n        const attributes = {};\n        const attributesArray = [];\n\n        const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n        for (let i = 0; i < totalAttributes; i++)\n        {\n            const attribData = gl.getActiveAttrib(program, i);\n            const type = shaderUtils.mapType(gl, attribData.type);\n\n            /*eslint-disable */\n            const data = {\n                type: type,\n                name: attribData.name,\n                size: shaderUtils.mapSize(type),\n                location: 0,\n            };\n            /*eslint-enable */\n\n            attributes[attribData.name] = data;\n            attributesArray.push(data);\n        }\n\n        attributesArray.sort((a, b) => (a.name > b.name) ? 1 : -1); // eslint-disable-line no-confusing-arrow\n\n        for (let i = 0; i < attributesArray.length; i++)\n        {\n            attributesArray[i].location = i;\n        }\n\n        return attributes;\n    }\n\n    /**\n     * returns the uniform data from the program\n     * @private\n     *\n     * @param {webGL-program} [program] - the webgl program\n     * @param {contex} [gl] - the webGL context\n     *\n     * @returns {object} the uniform data for this program\n     */\n    getUniformData(program, gl)\n    {\n        const uniforms = {};\n\n        const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n        // TODO expose this as a prop?\n       // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');\n        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');\n\n        for (let i = 0; i < totalUniforms; i++)\n        {\n            const uniformData = gl.getActiveUniform(program, i);\n            const name = uniformData.name.replace(/\\[.*?\\]/, '');\n\n            const isArray = uniformData.name.match(/\\[.*?\\]/, '');\n            const type = shaderUtils.mapType(gl, uniformData.type);\n\n            /*eslint-disable */\n            uniforms[name] = {\n                type: type,\n                size: uniformData.size,\n                isArray:isArray,\n                value: shaderUtils.defaultValue(type, uniformData.size),\n            };\n            /*eslint-enable */\n        }\n\n        return uniforms;\n    }\n\n    /**\n     * The default vertex shader source\n     *\n     * @static\n     * @constant\n     */\n    static get defaultVertexSrc()\n    {\n        return [\n            'attribute vec2 aVertexPosition;',\n            'attribute vec2 aTextureCoord;',\n\n            'uniform mat3 projectionMatrix;',\n\n            'varying vec2 vTextureCoord;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vTextureCoord = aTextureCoord ;',\n            '}',\n        ].join('\\n');\n    }\n\n    /**\n     * The default fragment shader source\n     *\n     * @static\n     * @constant\n     */\n    static get defaultFragmentSrc()\n    {\n        return [\n            'varying vec2 vTextureCoord;',\n\n            'uniform sampler2D uSampler;',\n\n            'void main(void){',\n            '   gl_FragColor *= texture2D(uSampler, vTextureCoord);',\n            '}',\n        ].join('\\n');\n    }\n\n    /**\n     * A short hand function to create a program based of a vertex and fragment shader\n     * this method will also check to see if there is a cached program.\n     *\n     * @param {string} [vertexSrc] - The source of the vertex shader.\n     * @param {string} [fragmentSrc] - The source of the fragment shader.\n     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.\n     *\n     * @returns {PIXI.Shader} an shiney new pixi shader.\n     */\n    static from(vertexSrc, fragmentSrc)\n    {\n        const key = vertexSrc + fragmentSrc;\n\n        let program = ProgramCache[key];\n\n        if (!program)\n        {\n            ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc);\n        }\n\n        return program;\n    }\n}\n\nexport default Program;\n"]}