{"version":3,"sources":["../../src/mesh/Plane.js"],"names":["Plane","texture","verticesX","verticesY","opts","Float32Array","Uint16Array","segmentsX","segmentsY","meshWidth","width","meshHeight","height","refresh","total","verts","uvs","indices","sizeX","sizeY","i","_uvs","x","y","push","x0","x1","y0","y3","totalSub","xpos","ypos","value","value2","value3","value4","shader","uniforms","alpha","uSampler2","vertices","geometry","buffers","data","indexBuffer","update","updateTransform","containerUpdateTransform"],"mappings":";;;;AAAA;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;IAeqBA,K;;;AAEjB;;;;;;AAMA,mBAAYC,OAAZ,EAAqBC,SAArB,EAAgCC,SAAhC,EACA;AAAA,YAD2CC,IAC3C,uEADkD,EAClD;;AAAA;;AAAA,qDACI,iBAAMH,OAAN,EAAe,IAAII,YAAJ,CAAiB,CAAjB,CAAf,EAAoC,IAAIA,YAAJ,CAAiB,CAAjB,CAApC,EAAyD,IAAIC,WAAJ,CAAgB,CAAhB,CAAzD,EAA6E,CAA7E,CADJ;;AAGI,cAAKC,SAAL,GAAiB,MAAKL,SAAL,GAAiBA,aAAa,EAA/C;AACA,cAAKM,SAAL,GAAiB,MAAKL,SAAL,GAAiBA,aAAa,EAA/C;;AAEA,cAAKM,SAAL,GAAiBL,KAAKK,SAAL,IAAkBR,QAAQS,KAA3C;AACA,cAAKC,UAAL,GAAkBP,KAAKO,UAAL,IAAmBV,QAAQW,MAA7C;;AAEA,cAAKC,OAAL;AATJ;AAUC;;AAED;;;;;;oBAIAA,O,sBACA;AACI,YAAMC,QAAQ,KAAKZ,SAAL,GAAiB,KAAKC,SAApC;AACA,YAAMY,QAAQ,EAAd;AACA,YAAMC,MAAM,EAAZ;AACA,YAAMC,UAAU,EAAhB;AACA,YAAMhB,UAAU,KAAKA,OAArB;;AAEA,YAAMM,YAAY,KAAKL,SAAL,GAAiB,CAAnC;AACA,YAAMM,YAAY,KAAKL,SAAL,GAAiB,CAAnC;;AAEA,YAAMe,QAAQ,KAAKT,SAAL,GAAiBF,SAA/B;AACA,YAAMY,QAAS,KAAKR,UAAL,GAAkBH,SAAjC;;AAEA,aAAK,IAAIY,IAAI,CAAb,EAAgBA,IAAIN,KAApB,EAA2BM,GAA3B,EACA;AACI,gBAAInB,QAAQoB,IAAZ,EACA;AACI,oBAAMC,IAAKF,IAAI,KAAKlB,SAApB;AACA,oBAAMqB,IAAMH,IAAI,KAAKlB,SAAV,GAAuB,CAAlC;;AAEAa,sBAAMS,IAAN,CAAYF,IAAIJ,KAAhB,EACYK,IAAIJ,KADhB;;AAGA;AACAH,oBAAIQ,IAAJ,CACIvB,QAAQoB,IAAR,CAAaI,EAAb,GAAmB,CAACxB,QAAQoB,IAAR,CAAaK,EAAb,GAAkBzB,QAAQoB,IAAR,CAAaI,EAAhC,KAAuCH,KAAK,KAAKpB,SAAL,GAAiB,CAAtB,CAAvC,CADvB,EAEID,QAAQoB,IAAR,CAAaM,EAAb,GAAmB,CAAC1B,QAAQoB,IAAR,CAAaO,EAAb,GAAkB3B,QAAQoB,IAAR,CAAaM,EAAhC,KAAuCJ,KAAK,KAAKpB,SAAL,GAAiB,CAAtB,CAAvC,CAFvB;AAIH,aAbD,MAeA;AACIa,oBAAIQ,IAAJ,CAAS,CAAT;AACH;AACJ;;AAED,YAAMK,WAAWtB,YAAYC,SAA7B;;AAEA,aAAK,IAAIY,KAAI,CAAb,EAAgBA,KAAIS,QAApB,EAA8BT,IAA9B,EACA;AACI,gBAAMU,OAAOV,KAAIb,SAAjB;AACA,gBAAMwB,OAAQX,KAAIb,SAAL,GAAkB,CAA/B;;AAEA,gBAAMyB,QAASD,OAAO,KAAK7B,SAAb,GAA0B4B,IAAxC;AACA,gBAAMG,SAAUF,OAAO,KAAK7B,SAAb,GAA0B4B,IAA1B,GAAiC,CAAhD;AACA,gBAAMI,SAAU,CAACH,OAAO,CAAR,IAAa,KAAK7B,SAAnB,GAAgC4B,IAA/C;AACA,gBAAMK,SAAU,CAACJ,OAAO,CAAR,IAAa,KAAK7B,SAAnB,GAAgC4B,IAAhC,GAAuC,CAAtD;;AAEAb,oBAAQO,IAAR,CAAaQ,KAAb,EAAoBC,MAApB,EAA4BC,MAA5B;AACAjB,oBAAQO,IAAR,CAAaS,MAAb,EAAqBE,MAArB,EAA6BD,MAA7B;AACH;;AAED,aAAKE,MAAL,CAAYC,QAAZ,CAAqBC,KAArB,GAA6B,CAA7B;AACA,aAAKF,MAAL,CAAYC,QAAZ,CAAqBE,SAArB,GAAiC,KAAKtC,OAAtC;;AAEA,aAAKuC,QAAL,GAAgB,IAAInC,YAAJ,CAAiBU,KAAjB,CAAhB;AACA,aAAKC,GAAL,GAAW,IAAIX,YAAJ,CAAiBW,GAAjB,CAAX;AACA,aAAKC,OAAL,GAAe,IAAIX,WAAJ,CAAgBW,OAAhB,CAAf;;AAEA,aAAKwB,QAAL,CAAcC,OAAd,CAAsB,CAAtB,EAAyBC,IAAzB,GAAgC,KAAKH,QAArC;AACA,aAAKC,QAAL,CAAcC,OAAd,CAAsB,CAAtB,EAAyBC,IAAzB,GAAgC,KAAK3B,GAArC;AACA,aAAKyB,QAAL,CAAcG,WAAd,CAA0BD,IAA1B,GAAiC,KAAK1B,OAAtC;;AAEA;AACA,aAAKwB,QAAL,CAAcC,OAAd,CAAsB,CAAtB,EAAyBG,MAAzB;AACA,aAAKJ,QAAL,CAAcC,OAAd,CAAsB,CAAtB,EAAyBG,MAAzB;AACA,aAAKJ,QAAL,CAAcG,WAAd,CAA0BC,MAA1B;AACH,K;;AAED;;;;;;;oBAKAC,e,8BACA;AACI,aAAKL,QAAL,CAAcC,OAAd,CAAsB,CAAtB,EAAyBG,MAAzB;AACA,aAAKE,wBAAL;AACH,K;;;;;kBAvGgB/C,K","file":"Plane.js","sourcesContent":["import Mesh from './Mesh';\n\n/**\n * The Plane allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let Plane = new PIXI.Plane(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n *\n */\nexport default class Plane extends Mesh\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use on the Plane.\n     * @param {number} verticesX - The number of vertices in the x-axis\n     * @param {number} verticesY - The number of vertices in the y-axis\n     * @param {object} opts - an options object - add meshWidth and meshHeight\n     */\n    constructor(texture, verticesX, verticesY, opts = {})\n    {\n        super(texture, new Float32Array(1), new Float32Array(1), new Uint16Array(1), 4);\n\n        this.segmentsX = this.verticesX = verticesX || 10;\n        this.segmentsY = this.verticesY = verticesY || 10;\n\n        this.meshWidth = opts.meshWidth || texture.width;\n        this.meshHeight = opts.meshHeight || texture.height;\n\n        this.refresh();\n    }\n\n    /**\n     * Refreshes\n     *\n     */\n    refresh()\n    {\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n        const texture = this.texture;\n\n        const segmentsX = this.verticesX - 1;\n        const segmentsY = this.verticesY - 1;\n\n        const sizeX = this.meshWidth / segmentsX;\n        const sizeY =  this.meshHeight / segmentsY;\n\n        for (let i = 0; i < total; i++)\n        {\n            if (texture._uvs)\n            {\n                const x = (i % this.verticesX);\n                const y = ((i / this.verticesX) | 0);\n\n                verts.push((x * sizeX),\n                           (y * sizeY));\n\n                // this works for rectangular textures.\n                uvs.push(\n                    texture._uvs.x0 + ((texture._uvs.x1 - texture._uvs.x0) * (x / (this.verticesX - 1))),\n                    texture._uvs.y0 + ((texture._uvs.y3 - texture._uvs.y0) * (y / (this.verticesY - 1)))\n                );\n            }\n            else\n            {\n                uvs.push(0);\n            }\n        }\n\n        const totalSub = segmentsX * segmentsY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % segmentsX;\n            const ypos = (i / segmentsX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3);\n            indices.push(value2, value4, value3);\n        }\n\n        this.shader.uniforms.alpha = 1;\n        this.shader.uniforms.uSampler2 = this.texture;\n\n        this.vertices = new Float32Array(verts);\n        this.uvs = new Float32Array(uvs);\n        this.indices = new Uint16Array(indices);\n\n        this.geometry.buffers[0].data = this.vertices;\n        this.geometry.buffers[1].data = this.uvs;\n        this.geometry.indexBuffer.data = this.indices;\n\n        // ensure that the changes are uploaded\n        this.geometry.buffers[0].update();\n        this.geometry.buffers[1].update();\n        this.geometry.indexBuffer.update();\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        this.geometry.buffers[0].update();\n        this.containerUpdateTransform();\n    }\n}\n"]}