{"version":3,"sources":["../../src/mesh/Rope.js"],"names":["core","Rope","texture","points","Float32Array","length","Uint16Array","refresh","vertexBuffer","geometry","getAttribute","uvBuffer","indexBuffer","getIndex","_uvs","data","uvs","indices","textureUvs","offset","Point","x0","y0","factor","x2","Number","y2","x","y","total","i","index","amount","update","updateTransform","lastPoint","nextPoint","perpX","perpY","vertices","point","ratio","perpLength","Math","sqrt","num","height","uniforms","alpha","worldAlpha","containerUpdateTransform","_onTextureUpdate"],"mappings":"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","file":"Rope.js","sourcesContent":["import Mesh from './Mesh';\nimport * as core from '../core';\n\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n *\n */\nexport default class Rope extends Mesh\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use on the rope.\n     * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.\n     */\n    constructor(texture, points)\n    {\n        super(texture, new Float32Array(points.length * 4),\n                       new Float32Array(points.length * 4),\n                       new Uint16Array(points.length * 2),\n                       5);\n\n        /*\n         * @member {PIXI.Point[]} An array of points that determine the rope\n         */\n        this.points = points;\n        this.refresh();\n    }\n\n    /**\n     * Refreshes\n     */\n    refresh()\n    {\n        const points = this.points;\n\n        if (!points) return;\n\n        const vertexBuffer = this.geometry.getAttribute('aVertexPosition');\n        const uvBuffer = this.geometry.getAttribute('aTextureCoord');\n        const indexBuffer = this.geometry.getIndex();\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1 || !this.texture._uvs)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (vertexBuffer.data.length / 4 !== points.length)\n        {\n            vertexBuffer.data = new Float32Array(points.length * 4);\n            uvBuffer.data = new Float32Array(points.length * 4);\n            indexBuffer.data = new Uint16Array(points.length * 2);\n        }\n\n        const uvs = uvBuffer.data;\n        const indices = indexBuffer.data;\n\n        const textureUvs = this.texture._uvs;\n        const offset = new core.Point(textureUvs.x0, textureUvs.y0);\n        const factor = new core.Point(textureUvs.x2 - textureUvs.x0, Number(textureUvs.y2 - textureUvs.y0));\n\n        uvs[0] = 0 + offset.x;\n        uvs[1] = 0 + offset.y;\n        uvs[2] = 0 + offset.x;\n        uvs[3] = factor.y + offset.y;\n\n        indices[0] = 0;\n        indices[1] = 1;\n\n        const total = points.length;\n\n        for (let i = 1; i < total; i++)\n        {\n            // time to do some smart drawing!\n            let index = i * 4;\n            const amount = i / (total - 1);\n\n            uvs[index] = (amount * factor.x) + offset.x;\n            uvs[index + 1] = 0 + offset.y;\n\n            uvs[index + 2] = (amount * factor.x) + offset.x;\n            uvs[index + 3] = factor.y + offset.y;\n\n            index = i * 2;\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n        }\n\n        // ensure that the changes are uploaded\n        vertexBuffer.update();\n        uvBuffer.update();\n        indexBuffer.update();\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        // this.count -= 0.2;\n\n        const vertexBuffer = this.geometry.getAttribute('aVertexPosition');\n        const vertices = vertexBuffer.data;\n\n        const total = points.length;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n            const num = this.texture.height / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\n            perpX /= perpLength;\n            perpY /= perpLength;\n\n            perpX *= num;\n            perpY *= num;\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n\n        // mark the buffer as requiring an upload..\n        vertexBuffer.update();\n\n        this.uniforms.alpha = this.worldAlpha;\n\n        this.containerUpdateTransform();\n    }\n\n    /**\n     * When the texture is updated, this event will fire to update the scale and frame\n     *\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        this.refresh();\n    }\n}\n"]}