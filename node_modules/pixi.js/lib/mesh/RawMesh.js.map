{"version":3,"sources":["../../src/mesh/RawMesh.js"],"names":["core","tempPoint","Point","tempPolygon","Polygon","RawMesh","geometry","shader","state","drawMode","DRAW_MODES","TRIANGLES","State","_glDatas","pluginName","start","size","_renderWebGL","renderer","batch","setObjectRenderer","plugins","render","_renderCanvas","_calculateBounds","attributes","aVertexPosition","vertices","getAttribute","data","_bounds","addVertices","transform","length","containsPoint","point","getBounds","contains","x","y","worldTransform","applyInverse","points","indices","getIndex","len","step","i","ind0","ind1","ind2","Container"],"mappings":"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","file":"RawMesh.js","sourcesContent":["import * as core from '../core';\n\nconst tempPoint = new core.Point();\nconst tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class.\n * The reason for this class is to empower you to have maximum flexbilty to render any kind of webGL you can think of.\n * This class assumes a certain level of webGL knowledge.\n * If you know a bit this should abstract enough away to make you life easier!\n * Pretty much ALL WebGL can be broken down into the following:\n * Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * Shader - This is the shader that pixi will render the geometry with. (attributes in the shader must match the geometry!)\n * Uniforms - These are the values passed to the shader when the mesh is rendered.\n * As a shader can be resued accross multiple objects, it made sense to allow uniforms to exist outside of the shader\n * State - This is the state of WebGL required to render the mesh.\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n */\nexport default class RawMesh extends core.Container\n{\n    /**\n     * @param {PIXI.mesh.Geometry} geometry  the geometry the mesh will use\n     * @param {PIXI.Shader} shader  the shader the mesh will use\n     * @param {PIXI.State} state  the state that the webGL context is required to be in to render the mesh\n     * @param {number} drawMode  the drawMode, can be any of the PIXI.DRAW_MODES consts\n     */\n    constructor(geometry, shader, state, drawMode = core.DRAW_MODES.TRIANGLES)\n    {\n        super();\n\n        /**\n         * the geometry the mesh will use\n         * @type {PIXI.mesh.Geometry}\n         */\n        this.geometry = geometry;\n\n        /**\n         * the shader the mesh will use\n         * @type {PIXI.Shader}\n         */\n        this.shader = shader;\n\n        /**\n         * the webGL state the mesh requires to render\n         * @type {PIXI.State}\n         */\n        this.state = state || new core.State();\n\n        /**\n         * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.RawMesh.DRAW_MODES} consts\n         *\n         * @member {number}\n         * @see PIXI.mesh.RawMesh.DRAW_MODES\n         */\n        this.drawMode = drawMode;\n\n        /**\n         * The way uniforms that will be used by the mesh's shader.\n         * @member {Object}\n         */\n\n        /**\n         * A map of renderer IDs to webgl render data\n         *\n         * @private\n         * @member {object<number, object>}\n         */\n        this._glDatas = {};\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.\n         *\n         * @member {string}\n         * @default 'mesh'\n         */\n        this.pluginName = 'mesh';\n\n        this.start = 0;\n        this.size = 0;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer a reference to the WebGL renderer\n     * @private\n     */\n    _renderWebGL(renderer)\n    {\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    _renderCanvas(renderer)\n    {\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     * there must be a aVertexPosition attribute present in the geometry for bounds to be calcualted correctly.\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        // The position property could be set manually?\n        if (this.geometry.attributes.aVertexPosition)\n        {\n            const vertices = this.geometry.getAttribute('aVertexPosition').data;\n\n            // TODO - we can cache local bounds and use them if they are dirty (like graphics)\n            this._bounds.addVertices(this.transform, vertices, 0, vertices.length);\n        }\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n     *\n     * @param {PIXI.Point} point the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.geometry.getAttribute('aVertexPosition').data;\n\n        const points = tempPolygon.points;\n        const indices =  this.geometry.getIndex().data;\n        const len = indices.length;\n        const step = this.drawMode === 4 ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"]}